

use crate::ast::*;
use crate::tokens::Token;
use crate::errors::{ LexicalError };


grammar;

pub File: File = {
	<body: Statement*> => File { body }
}

SimpleType: Type = {
	"string" => Type::String,
	"timestamp" => Type::Timestamp,
	"boolean" => Type::Boolean,
	"byte" => Type::Byte,
	"short" => Type::Short,
	"integer" => Type::Integer,
	"long" => Type::Long,
	"float" => Type::Float,
	"double" => Type::Double,
}



Statement: Statement = {
	"service" <id:Ident> "{" <properties: Comma<Prop>> "}" => Statement::ServiceDef { id, properties },
	"struct" <id:Ident> "{" <properties: Comma<Prop>> "}" => Statement::StructDef { id, properties },
	"operation" <id:Ident> "{" <properties: Comma<Prop>> "}" => Statement::OperationDef { id, properties },
	<_type: SimpleType> <id: Ident> => Statement::SimpleTypeDef { id, _type },
}


Prop: Property = {
	<id:Ident>":"<value: Expr> => Property { id, value }
}

Ident: Identifier = {
	<name: "identifier"> => Identifier { name }
}

Expr: Expression = {
	"{" <properties: Comma<Prop>> "}" => Expression::ObjectExpression { properties },
	<name: "identifier"> => Expression::Identifier{ name },
	"[" <elements: Comma<Ident>> "]" => Expression::ArrayExpression { elements },
	"literal_int" => Expression::Literal(Literal::Integer(<>)),
	"literal_string" => Expression::Literal(Literal::String(<>)),
	"literal_float" => Expression::Literal(Literal::Float(<>)),
}


Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};




extern {
	type Location = usize;
	type Error = LexicalError;
	enum Token {
	    "service" => Token::KwService,
	    "operation" => Token::KwOperation,
	    "import" => Token::KwImport,
	    "from" => Token::KwFrom,
	    "struct" => Token::KwStruct,
	    "string" => Token::KwString,
	    "timestamp" => Token::KwTimestamp,
	    "boolean" => Token::KwBoolean,
	    "byte" => Token::KwByte,
	    "short" => Token::KwShort,
	    "integer" => Token::KwInt,
	    "long" => Token::KwLong,
	    "float" => Token::KwFloat,
	    "double" => Token::KwDouble,
	    "{" => Token::LBrace,
	    "}" => Token::RBrace,
	    "[" => Token::LBracket,
	    "]" => Token::RBracket,
	    ":" => Token::Colon,
	    "," => Token::Comma,
	    "@" => Token::At,
	    "-" => Token::Dash,
	    "$" => Token::Dollar,
	    "identifier" => Token::Identifier(<String>),
	    "literal_int" => Token::Integer(<i64>),
	    "literal_string" => Token::String(<String>),
	    "literal_float" => Token::Float(<f64>),
	}
}
