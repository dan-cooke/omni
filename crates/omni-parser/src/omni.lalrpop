use omni_ast::{Mod, Def, Ident, Int, Prop, Value};


use crate::tokens::Token;
use crate::errors::{ LexicalError, Error };

use lalrpop_util::ParseError;


grammar;

pub Mod: Mod = {
	<stmts: stmt*> => Mod::Module { body: stmts },
}

stmt: Def = {
	"service" <id:"identifier"> <body:struct> =>? match body {
		Value::Object(props) => Ok(Def::ServiceDef { id, body: props }),
		_ =>  Err(ParseError::User { error: LexicalError::InvalidToken(String::from("Expected struct definition"))}),
	},

	"resource" <id:"identifier"> <body:struct> =>? match body {
		Value::Object(props) => Ok(Def::ResourceDef { id, body: props }),
		_ =>  Err(ParseError::User { error: LexicalError::InvalidToken(String::from("Expected struct definition"))}),
	},
	"operation" <id:"identifier"> <body:struct> =>? match body {
		Value::Object(props) => Ok(Def::OperationDef { id, body: props }),
		_ =>  Err(ParseError::User { error: LexicalError::InvalidToken(String::from("Expected struct definition"))}),
	}
}

struct: Value = {
	"{"<props: Comma<prop>>"}" => Value::Object(<>),
}
prop: Prop = {
	<id:"identifier">":"<val: value> => Prop { id, value: val }
}

value: Value = {
	"identifier" => Value::Identifier(<>),
	"int" => Value::Integer(<>),
	"str" => Value::String(<>),
	"["<vals: Comma<value>>"]" => Value::Array(vals),
	struct,
}



Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};



extern {
	type Location = usize;
	type Error = LexicalError;

	enum Token {
		"service" => Token::KwService,
		"resource" => Token::KwResource,
		"operation" => Token::KwOperation,
		"{" => Token::LBrace,
		"}" => Token::RBrace,
		"[" => Token::LBracket,
		"]" => Token::RBracket,
		":" => Token::Colon,
		"," => Token::Comma,
		"," => Token::Comma,
		"@" => Tokenn::At,
		"identifier" => Token::Identifier(<String>),
		"int" => Token::Integer(<i64>),
		"str" => Token::String(<String>),
	}
}
